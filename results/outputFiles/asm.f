[ifndef $C_varEnd

	hFB wconstant $C_varEnd

]

[ifndef $C_rsTop

	hFB wconstant $C_rsTop

]

[ifndef $C_rsBot

	hE5 wconstant $C_rsBot

]

[ifndef $C_stTop

	hE5 wconstant $C_stTop

]

[ifndef $C_this

	hE4 wconstant $C_this

]

[ifndef $C_stBot

	hCD wconstant $C_stBot

]

[ifndef $C_treg6

	hCC wconstant $C_treg6

]

[ifndef $C_treg5

	hCB wconstant $C_treg5

]

[ifndef $C_treg4

	hCA wconstant $C_treg4

]

[ifndef $C_treg3

	hC9 wconstant $C_treg3

]

[ifndef $C_cogdata

	hC9 wconstant $C_cogdata

]

[ifndef $C_stTOS

	hC8 wconstant $C_stTOS

]

[ifndef $C_rsPtr

	hC7 wconstant $C_rsPtr

]

[ifndef $C_stPtr

	hC6 wconstant $C_stPtr

]

[ifndef $C_resetDreg

	hC5 wconstant $C_resetDreg

]

[ifndef $C_fLongMask

	hC4 wconstant $C_fLongMask

]

[ifndef $C_fAddrMask

	hC3 wconstant $C_fAddrMask

]

[ifndef $C_fCondMask

	hC2 wconstant $C_fCondMask

]

[ifndef $C_fDestInc

	hC1 wconstant $C_fDestInc

]

[ifndef $C_a_rsPop_ret

	hC0 wconstant $C_a_rsPop_ret

]

[ifndef $C_a_rsPop1

	hBF wconstant $C_a_rsPop1

]

[ifndef $C_a_rsPop

	hBA wconstant $C_a_rsPop

]

[ifndef $C_a_stpopC_treg_ret

	hB9 wconstant $C_a_stpopC_treg_ret

]

[ifndef $C_a_stPop_ret

	hB9 wconstant $C_a_stPop_ret

]

[ifndef $C_a_stPop1

	hB8 wconstant $C_a_stPop1

]

[ifndef $C_a_stPop

	hB3 wconstant $C_a_stPop

]

[ifndef $C_a_stpopC_treg

	hB2 wconstant $C_a_stpopC_treg

]

[ifndef $C_a_rsPush_ret

	hB1 wconstant $C_a_rsPush_ret

]

[ifndef $C_a_rsPush1

	hAF wconstant $C_a_rsPush1

]

[ifndef $C_a_rsPush

	hAB wconstant $C_a_rsPush

]

[ifndef $C_a_stPush_ret

	hAA wconstant $C_a_stPush_ret

]

[ifndef $C_a_stPush1

	hA8 wconstant $C_a_stPush1

]

[ifndef $C_a_stPush

	hA4 wconstant $C_a_stPush

]

[ifndef $C_a_lasterr

	hA1 wconstant $C_a_lasterr

]

[ifndef $C_a_reset

	hA0 wconstant $C_a_reset

]

[ifndef $C_a_0branch

	h9C wconstant $C_a_0branch

]

[ifndef $C_a_(+loop)

	h91 wconstant $C_a_(+loop)

]

[ifndef $C_a_(loop)

	h8F wconstant $C_a_(loop)

]

[ifndef $C_a_>r

	h8B wconstant $C_a_>r

]

[ifndef $C_a_2>r

	h88 wconstant $C_a_2>r

]

[ifndef $C_a_r>

	h84 wconstant $C_a_r>

]

[ifndef $C_a__maskoutlo

	h81 wconstant $C_a__maskoutlo

]

[ifndef $C_a__maskouthi

	h80 wconstant $C_a__maskouthi

]

[ifndef $C_a__maskin

	h7D wconstant $C_a__maskin

]

[ifndef $C_a_next

	h75 wconstant $C_a_next

]

[ifndef $C_a_exit

	h73 wconstant $C_a_exit

]

[ifndef $C_a_litw1

	h71 wconstant $C_a_litw1

]

[ifndef $C_a_litw

	h6F wconstant $C_a_litw

]

[ifndef $C_a_litl

	h69 wconstant $C_a_litl

]

[ifndef $C_a_doconl

	h64 wconstant $C_a_doconl

]

[ifndef $C_a_dovarw

	h61 wconstant $C_a_dovarw

]

[ifndef $C_a_dovarl

	h5F wconstant $C_a_dovarl

]

[ifndef $C_a_doconw

	h5C wconstant $C_a_doconw

]

[ifndef $C_a_branch

	h58 wconstant $C_a_branch

]

[ifndef $C_a_COG!

	h54 wconstant $C_a_COG!

]

[ifndef $C_a_ST!

	h4F wconstant $C_a_ST!

]

[ifndef $C_a_RS!

	h49 wconstant $C_a_RS!

]

[ifndef $C_a_COGat

	h45 wconstant $C_a_COGat

]

[ifndef $C_a_STat

	h40 wconstant $C_a_STat

]

[ifndef $C_a_RSat

	h3A wconstant $C_a_RSat

]

[ifndef $C_a_drop

	h38 wconstant $C_a_drop

]

[ifndef $C_a__xasm2>0

	h33 wconstant $C_a__xasm2>0

]

[ifndef $C_a__xasm1>1

	h2E wconstant $C_a__xasm1>1

]

[ifndef $C_a__xasm2>1

	h28 wconstant $C_a__xasm2>1

]

[ifndef $C_a__xasm2>1IMM

	h25 wconstant $C_a__xasm2>1IMM

]

[ifndef $C_a__xasm2>flag

	h16 wconstant $C_a__xasm2>flag

]

[ifndef $C_a__xasm2>flagIMM

	h13 wconstant $C_a__xasm2>flagIMM

]

[ifndef $C_a_lxasm

	h3 wconstant $C_a_lxasm

]

[ifndef $C_IP

	h2 wconstant $C_IP

]

[ifndef $C_treg2

	h1 wconstant $C_treg2

]

[ifndef $C_treg1

	h0 wconstant $C_treg1

]





1 wconstant asm.f

[ifndef variable

: variable lockdict create $C_a_dovarl w, 0 l, forthentry freedict ;

]

variable asmDestBuffer -1 asmDestBuffer L!

\ stringmap mapname ( -- )

[ifndef stringmap

: stringmap

create forthentry $C_a_dovarw w,

;

]

\ defineLocalLabel ( addr cstr -- )

: defineLocalLabel

lockdict ccreate $C_a_doconw w, w, forthentry freedict

;

: definePatch

lockdict ccreate

$H_cq w, dup here W@ ccopy C@ 1+ allot herewal

$C_a_litw w, h1FF and swap if h8000 or then w,

$C_a_exit w,

forthentry freedict

;

\ padnw ( -- t/f ) move past current word and parse the next word, true if there is a next word

[ifndef padnw

: padnw

	nextword

	parsebl

;

]

\

\

\ (forget) ( cstr -- ) wind the dictionary back to the word which follows - caution

[ifndef (forget)

: (forget)

	dup

	if

		find

		if

			pfa>nfa nfa>lfa dup here W! W@ wlastnfa W!

		else

			_p?

			if

				.cstr h3F emit cr

			then

		then

	else

		drop

	then

;

]

\

\ forget ( -- ) wind the dictionary back to the word which follows - caution

[ifndef forget

: forget

	parsenw (forget)

;

]

\ string/word ( cstr word -- )

[ifndef string/word

: string/word

	swap here W@ over C@ 1+ allot herewal ccopy w,

;

]  

\

\ string/word_lookup ( cstr map -- cstr 0 | word -1)

[ifndef string/word_lookup

: string/word_lookup

	0 rot2

	begin

		2dup cstr=

		if

			C@++ + alignw dup W@ 1 ST! -1 2 ST! -1

		else

			C@++ + alignw 2+ dup C@ 0=

		then

	until

	drop swap

;

]

\ string/long ( cstr long -- )

[ifndef string/long

: string/long

	swap here W@ over C@ 1+ allot herewal ccopy l,

;

]  

\

\ string/long_lookup ( cstr map -- cstr 0 | long -1)

[ifndef string/long_lookup

: string/long_lookup

	0 rot2

	begin

		2dup cstr=

		if

			C@++ + alignl dup L@ 1 ST! -1 2 ST! -1

		else

			C@++ + alignl 4+ dup C@ 0=

		then

	until

	drop swap

;

]

[ifndef lastdef

\ lastdef ( c-addr -- t/f ) true if this is the most recently defined word 

: lastdef

	lastnfa over _dictsearch dup

	if

		=

	else

		2drop -1

	then

; 

]

\

wvariable _numPatches 0 _numPatches W!

wvariable _asmerror 0 _asmerror W!

\

wvariable _asmaddr 0 _asmaddr W!

\

0 wconstant _image



\

\

\ asm, ( long -- )

: asm,

	_image _asmaddr W@ 0 max h1EF min 4* + L!

	1 _asmaddr W+!

;

\

\ asm! ( long addr -- )

: asm!

	0 max h1EF min 4* _image + L!

;

\

\ asm@ ( addr -- long )

: asm@

	0 max h1EF min 4* _image + L@

;

\ isLocalLabel ( cstr -- t/f)

: isLocalLabel

		dup c" __" npfx swap c" C_" npfx or

;

\

\ : localLabelPrefix

\	c" __"

\ ;

\

\ patchName ( n -- cstr) uses tbuf

: patchName

	c" __%%" tbuf ccopy <# # # # # #> tbuf cappend tbuf

;

\

\

\ definePatch ( dstflag addr cstr1 cstr2 -- ) create a word named cstr2

\

\ worddefinedbycstr2 ( -- cstr1 n1) 

\

\

\ addPatch ( dstflag addr cstr1 -- )

: addPatch

	_numPatches W@ patchName definePatch

	1 _numPatches W+!

;

\

\

lockdict stringmap _cnd

c" if_always"		h003C	string/word

c" if_never"		0	string/word

c" if_e"		h0028	string/word

c" if_ne"		h0014	string/word

c" if_a"		h0004	string/word

c" if_b"		h0030	string/word

c" if_ae"		h000C	string/word

c" if_be"		h0038	string/word

c" if_c"		h0030	string/word

c" if_nc"		h000C	string/word

c" if_z"		h0028	string/word

c" if_nz"		h0014	string/word

c" if_c_eq_z"		h0024	string/word

c" if_c_ne_z"		h0018	string/word

c" if_c_and_z"		h0020	string/word

c" if_c_and_nz"		h0010	string/word

c" if_nc_and_z"		h0008	string/word

c" if_nc_and_nz"	h0004	string/word

c" if_c_or_z"		h0038	string/word

c" if_c_or_nz"		h0034	string/word

c" if_nc_or_z"		h002C	string/word

c" if_nc_or_nz"		h001C	string/word

c" if_z_eq_c"		h0024	string/word

c" if_z_ne_c"		h0018	string/word

c" if_z_and_c"		h0020	string/word

c" if_z_and_nc"		h0008	string/word

c" if_nz_and_c"		h0010	string/word

c" if_nz_and_nc"	h0004	string/word

c" if_z_or_c"		h0038	string/word

c" if_z_or_nc"		h002C	string/word

c" if_nz_or_c"		h0034	string/word

c" if_nz_or_nc"		h001C	string/word

c" "			0 	string/word

freedict

\

\

lockdict stringmap _asmds

c" abs"		hA8BC string/word

c" absneg"	hACBC string/word

c" add"		h80BC string/word

c" addabs"	h88BC string/word

c" adds"	hD0BC string/word

c" addsx"	hD8BC string/word

c" addx"	hC8BC string/word

c" and"		h60BC string/word

c" andn"	h64BC string/word

c" cmp"		h843C string/word

c" cmps"	hC03C string/word

c" cmpsub"	hE03C string/word

c" cmpsx"	hC43C string/word

c" cmpx"	hCC3C string/word

c" djnz"	hE4BC string/word

c" jmpret"	h5CBC string/word

c" max" 	h4CBC string/word

c" maxs"	h44BC string/word

c" min"		h48BC string/word

c" mins"	h40BC string/word

c" mov"		hA0BC string/word

c" movd"	h54BC string/word

c" movi"	h58BC string/word

c" movs"	h50BC string/word

c" muxc"	h70BC string/word

c" muxnc"	h74BC string/word

c" muxnz"	h7CBC string/word

c" muxz"	h78BC string/word

c" neg"		hA4BC string/word

c" negc"	hB03C string/word

c" negnc"	hB4BC string/word

c" negnz"	hBCBC string/word

c" negz"	hB9BC string/word

c" or"		h68BC string/word

c" rdbyte" 	h00BC string/word

c" rdlong"	h08BC string/word

c" rdword"	h04BC string/word

c" rcl"		h34BC string/word

c" rcr"		h30BC string/word

c" rev"		h3CBC string/word

c" rol"		h24BC string/word

c" ror"		h20BC string/word

c" sar"		h38BC string/word

c" shl"		h2CBC string/word

c" shr"		h28BC string/word

c" sub"		h84BC string/word

c" subabs"	h8CBC string/word

c" subs"	hD4BC string/word

c" subsx"	hDCBC string/word

c" subx"	hCCBC string/word

c" sumc"	h90BC string/word

c" sumnc"	h94BC string/word

c" sumnz"	h9CBC string/word

c" sumz"	h98BC string/word

c" test"	h603C string/word

c" testn"	h643C string/word

c" tjnz"	hE83C string/word

c" tjz"		hEC3C string/word

c" waitcnt"	hF8BC string/word

c" waitpeq"	hF03C string/word

c" waitpne"	hF43C string/word

c" waitvid"	hFC3C string/word

c" wrbyte"	h003C string/word

c" wrlong"	h083C string/word

c" wrword"	h043C string/word

c" xor"		h6CBC string/word

c" "		0 string/word

freedict

\

lockdict stringmap _asmd

c" clkset"	h0C7C0000 string/long

c" cogid"	h0CFC0001 string/long

c" coginit"	h0C7C0002 string/long

c" cogstop"	h0C7C0003 string/long

c" lockclr"	h0C7C0007 string/long

c" locknew"	h0CFC0004 string/long

c" lockret"	h0C7C0005 string/long

c" lockset"	h0C7C0006 string/long

c" "		0 string/long

freedict

\

lockdict stringmap _asms

c" jmp" 	h5C3C string/word

c" long"	0 string/word

c" "		0 string/word

freedict

\

lockdict stringmap _asm

c" nop"		0 string/long

c" ret"		h5C7C0000 string/long

c" jnext" 	$C_a_next h5C7C0000 or string/long

c" jexit"	$C_a_exit h5C7C0000 or string/long

c" spush"	$C_a_stPush $C_a_stPush_ret h9 lshift or h5CFC0000 or string/long

c" spopt"	$C_a_stpopC_treg $C_a_stpopC_treg_ret h9 lshift or h5CFC0000 or string/long

c" spop"	$C_a_stPop $C_a_stPop_ret h9 lshift or h5CFC0000 or string/long

c" rpush"	$C_a_rsPush $C_a_rsPush_ret h9 lshift or h5CFC0000 or string/long

c" rpop" 	$C_a_rsPop $C_a_rsPop_ret h9 lshift or h5CFC0000 or string/long

c" "		0 string/long

freedict

\

\

\ _lu ( cstr map -- cstr 0 | n1 -1) 

: _lu

	string/word_lookup dup if swap h10 lshift swap then

;

\

\ cnd ( cstr -- cstr 0 | n1 -1 ) process the condition statement n1 is the mask to apply if successful 

: cnd 

	_cnd _lu

;

\ 

\ asminstds ( cstr -- cstr 0 | n1 -1 ) process op codes with a destination and a source

: asminstds

	_asmds _lu

;

\ 

\ asminstd ( cstr -- cstr 0 | n1 -1 ) process opcodes with a destination only 

: asminstd

	_asmd string/long_lookup 

;

\

\ asminsts ( cstr -- cstr 0 | n1 -1 ) process opcodes with a source only

: asminsts

	_asms _lu

;

\

\ asminst ( cstr -- cstr 0 | n1 -1 ) process the only opcode with no dest or source

: asminst

	_asm string/long_lookup 

;

\

\ asmerr ( cstr cstr -- ) report an error and consume all the keys left

: asmerr

	.cstr .cstr cr padbl clearkeys -1 _asmerror W!

;

\

\

\ evalop3 ( t/f cstr -- cstr n1 ) t/f 0 - source op, -1 dest op, evaluate the operand as either as a forth word, a number,

\ or a local label

: evalop3

	hFDEB0317 rot2

\ forth word

	dup 

	find -1 =

\ ( t/f cstr addr flag -- )

	if

\ need to make sure the stack value is right

\ ( t/f cstr addr  -- )

		execute

\ ( t/f cstr value -- )

		rot drop

\ ( cstr value -- )

	else

\ ( t/f cstr cstr -- )

		isLocalLabel

		if

\ ( t/f cstr -- )

			tuck

\ ( cstr t/f cstr -- )

			_asmaddr W@ swap addPatch

			0

\ ( cstr 0 -- )

		else

\ ( t/f cstr -- )

			nip dup

\ ( cstr cstr -- )

			dup C@++ xisnumber

			if

				C@++ xnumber

			else

				c" ? " asmerr 0

			then

\ ( cstr value -- )

		then

	then

\ ( cstr value -- )

	rot hFDEB0317 <>

	if

		over c" ? " asmerr

	then

;

\

\ evalop2 ( t/f cstr -- n1 ) t/f 0 - source op, -1 dest op, evaluate the operand as either as a forth word, a number,

\ or a local label

: evalop2

	evalop3

\ ( cstr value -- )

	nip

;

\

\ evalop1 ( t/f cstr -- n1 ) t/f 0 - source op, -1 dest op, evaluate the operand as either as a forth word, a number,

\ or a local label

: evalop1

	evalop3

\ ( cstr value -- )

	dup 0 h1FF between

	if

		nip

	else

		drop c" ? " asmerr 0

	then

;

\

\ evalop ( t/f cstr -- n1 ) t/f 0 - source op, -1 dest op, evaluate the operand as either as a forth word, a number,

\ or a local label

: evalop

	evalop1 h1FF and

;

\

\ asmsrc ( n1 -- n1 ) n1 is the asm opcode, can be modified to set the immediate bit, the operand is evaluated as

\ a forth word/number

: asmsrc

	padnw 

	if

		pad>in c" #" cstr=

		if

			h00400000 or padnw

		else

			-1

		then

		if

			0 pad>in evalop or 0

		else

			-1

		then

	else

		-1

	then

	if

		c" Source Operand" c"  ?" asmerr

	then

;

\

\ asmdst ( n1 -- n1 ) n1 is the asm opcode

: asmdst

	padnw

	if

		-1 pad>in evalop h9 lshift or 0

	else

		-1

	then

	if

		." Dest Operand" c"  ?" asmerr

	then

;

\

\ (label) ( n1 n2 -- n3 n4 ) check to make sure the rest of the pad is empty

\ if not generate an error and set n3 = -1 & n4 = 0

: (label)

	padnw

	if

		pad>in c" Unexpected data after a label:" asmerr drop -1 swap

	then

;

\

\ asmopend ( n2 n1 -- n3 ) or in the update conditions

: asmopend

	padnw

	if

		begin

			pad>in dup 1+ C@ 27 <> 

			if

				dup c" wc" cstr= if drop h01000000 or else

				dup c" wz" cstr= if drop h02000000 or else

				dup c" wr" cstr= if drop h00800000 or else

				dup c" nr" cstr= if drop hFF7FFFFF and else

				c" Unexpected word " asmerr then then then then  

			else

				drop padbl

			then

			padnw 0=

		until

	then

	dup 0=

	if

		nip

	else

		hFFC3FFFF and or

	then

;

\

\ asmdstsrc ( n1 -- n1 )

: asmdstsrc

	asmdst padnw 

	if

		pad>in c" ," cstr=

		if

			asmsrc 0

		else

			-1

		then

			else -1

	then

	if

		." Expected" c"  ," asmerr

	else

		asmopend

	then

;

\

\ asmdone ( cogstart -- )

: asmdone

	_numPatches W@

	if

	_numPatches W@ 0 

		do

			i patchName find

			if

				execute

\ ( cstr patch_addr -- )

				swap find

				if

\ ( patch_addr addr -- )

					execute

\ ( patch_addr patch_data -- )

					swap dup h8000 and swap h7FFF and swap

\ (  patch_data patch_addr destFlag -- )

					over asm@ swap

\ (  patch_data patch_addr ASMINST destFlag -- )

					if

\ (  patch_data patch_addr ASMINST -- )

						rot h9 lshift or swap asm!

					else

						rot or swap asm!

					then

				else

\ ( patch_addr cstr -- )

					nip c" Undefined Label "

					asmerr

					cr

				then

			else

				c" Undefined Patch " asmerr

				cr

			then

		loop

	then

\

	_asmerror W@

	if

		drop

	else

		_asmaddr W@

		asmDestBuffer L@ -1 =

		if

			." lockdict create " padnw

			if

				pad>in .cstr space

			else

				." defasm "

			then

			." forthentry" cr

			." $C_a_lxasm w, "

			2dup

			h68 emit u. space h68 emit u. 

			."  1- tuck - h9 lshift swap h1FF and or here W@ alignl h10 lshift or l," cr

		then

		swap 0 rot2

		do

			

			i asm@

			asmDestBuffer L@ -1 <>

			if

				asmDestBuffer L@ L! asmDestBuffer L@ 4+ asmDestBuffer L!

			else

				dup 0=

				if

					drop ." 0 l, "

				else

					h68 emit base W@ h10 base W! swap u. base W!

\					h7A emit base W@ h40 base W! swap u. base W!

					." l, "

				then

				1+ dup h8 >=

				if

					drop

					0 cr

				then

			then

		loop

		drop

		cr ." freedict" cr

	then

;

\

\ asmline ( -- t/f )

: asmline

	parsebl dup

	if

		pad>in 1+ C@ dup h27 <> swap h5C <> and and

	then

	0=

\ not a blank line, and not a comment line

	if

		padbl

		0 0

	else

		pad>in c" ;asm" name= 



\ assembler done

		if

			-1 0

		else

\ we have a local label

			pad>in isLocalLabel

			if

				_asmaddr W@ pad>in defineLocalLabel

				0 0 (label) nextword

			else

\ process the condition, default to "if_always"

				pad>in cnd

				if

					padnw

					if

						0 swap -1

					else

						c" Opcode"

						c"  ?" asmerr

						-1 0

					then

				else

					drop 0 h003C0000 -1

				then

			then

		then

	then

\

	if

		pad>in asminst

\ process in the op-code, source, dest, and update flags

		if

			asmopend asm,

		else

			asminsts

			if

				asmsrc asmopend asm,

			else

				asminstd

				if

					asmdst asmopend asm,

				else

					asminstds

					if

						asmdstsrc asm,

					else

						2drop 0 pad>in evalop2 asm, nextword

	thens

;

\

\ _rasms

: _rasms

	lockdict

	_image 0=

	if

		herelal here W@ d_512 4* allot

		c" _image" find

		if

			2+ W!

		then

	then

	_image d_512 4* 0 fill



	_asmaddr W!

	base W@ hex

	1 _asmaddr W+!

	0 _asmerror W!



	0 c" __%%ASM" defineLocalLabel

\		

	0 _numPatches W!

	_asmaddr W@

	begin

		accept

		0 >in W!

		asmline

		dup 0=

		if

			parsenw dup

			if

				c" ?" swap asmerr

			else

				drop

			then

		then

		_asmerror W@ or

	until

	_asmerror W@

	if

		drop

	else

		cr cr

		asmdone

		padbl

	then



	cr cr

;

\ _rasme

: _rasme

	padnw

	drop

	base W!

\	

\

	c" __%%ASM" (forget)

\

	freedict

;

\ :rasm ( asmaddr -- )

: :rasm

	-1 asmDestBuffer L!

	 _rasms

	 _rasme

;

\

\

: :asm

	coghere W@ :rasm

;



: asmoptsymgen

	lastnfa

	begin



		dup c" C_" npfx

		if

			dup lastdef

			if

				." [ifndef $" dup .strname ." ~h0D~h09h"

				dup nfa>pfa 2+ W@ . ." wconstant $" dup .strname ." ~h0D]~h0D"

			then

		then		

		nfa>next dup 0=

	until

	drop

	cr cr 

;

: asmsymgen

	lastnfa

	begin

		dup c" C_" npfx

		if

			dup lastdef

			if

				." h" dup nfa>pfa 2+ W@ . ." wconstant $" dup .strname cr

			then

		then		

		nfa>next dup 0=

	until

	drop

	cr cr 

;



